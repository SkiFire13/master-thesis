#import "../../config/common.typ": *

== Parity games

TODO: Informal description of parity games
// TODO: Image example of parity game?

// TODO: integrate in the informal description
Players are also sometimes called $lozenge$ and $square$ or $exists$ and $forall$ due to their meaning when using parity games for solving $mu$-calculus or fixpoints.

// TODO: integrate in the informal description
$p$ is usually also called the *priority function* or coloring of the graph. Its codomain is traditionally taken to be $bb(N)$, but it can be shown to be equivalent to any totally ordered set $P$ partitioned into $P_0$ and $P_1$, respectively corresponding to the set of even and odd priorities.

Since we will often use the set of predecessors and successors of a vertex we will define a convenient notation for them. We will also need a formal concept for infinitely recurring elements in a sequence in order to describe the winner of a parity game.

#notation("successors and predecessors")[
  Let $G = (V, E)$ be a graph.
  Given $u, v in V$ we write $u E v$ if the graph contains the edge from $u$ to $v$.
  We write $u E$ as a shorthand for the set ${ v in V | u E v }$ and $E v$ as a shorthand for the set ${ u in V | u E v }$
]

#definition("infinitely recurring elements")[
  Let $pi = v_0 v_1 v_2 ...$ an infinite sequence of elements. We define $inf(pi)$ as the set of infinitely recurring elements of $pi$, that is $inf(pi) = { v | forall n. exists i >= n. v_i = v }$.
]

#definition("parity graph")[
  Let $V$ be a finite set of vertices, $E subset.eq V times V$ a set of edges, and $p: V -> bb(N)$ a so called priority function. A parity graph is a graph $G = (V, E, p)$.
]

// TODO: Concept of "moves" is still too informal.
#definition("parity game, play")[
  Let $(V, E, p)$ be a parity graph and let $V$ be partitioned into two sets $V_0$ and $V_1$. A parity game $G = (V_0, V_1, E, p)$ is a game played between two players 0 and 1 on G, where player $i$ controls the "moves" made from vertices in $V_i$.

  Starting from a vertex $v_0 in V$ we can build a potentially infinite sequence $pi = v_0 v_1 ...$ called a *play*, following the moves performed by the two players. We require that $forall i. v_i E v_(i+1)$, and in case this sequence is finite, that is $pi = v_0 v_1 ... v_n$, we also require $v_n E = emptyset$.

  Given a play we define its *winner*:
  - if it is finite, that is $pi = v_0 v_1 ... v_n$ with $v_n in V_i$ then the winner is player $1-i$;
  - if it is infinite then consider $max inf(p(v_0) p(v_1) ...)$: if it is even the winner is player 0, otherwise it is player 1.
]

We will however focus on parity games that are more restriced than this, in particular we will focus on _bipartite parity games_ and _total parity games_.
Bipartite parity games are parity games whose underlying graph is bipartite, which forces players to perfectly alternate moves.
Total parity games instead require every vertex to have at least one successor, thus forcing every play to be infinite.

We will mostly assume bipartite parity games, while we will show that we can convert any parity game in a compatible total parity game.

#definition("bipartite parity game")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. It is also a bipartite parity game if the graph $(V_0, V_1, E)$ is bipartite, that is $forall v in V_i. v E sect V_i = emptyset$.
]

#definition("total parity game")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. It is also a total parity game if every vertex has at least one successor, that if $forall v in V_0 union V_1. v E != emptyset$.
]

=== Strategies

The strategy iteration algorithm heavely depends on the concept of _strategies_, which intuitively represent the way a player can choose its moves in a parity game. We will then see plays as being generated by such strategies, and use this to define what it means to be the winner of a parity game on given vertex.

#definition("strategy")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. A strategy for player $i$ is a function taking as input the prefix $v_0 v_1 ... v_n$ of a play such that $v_n in V_i$ and $v_n E != emptyset$ and returns a vertex in $v_n E$.
]

#definition("strategy induced instance")[
  Let $G = (V_0, V_1, E, p)$ be a parity game, $sigma$ be a strategy for player 0 and $tau$ be a strategy for player 1. An instance of the game $G$ induced by the strategies $sigma$ and $tau$ is a tuple $(G, sigma, tau)$.

  Given a starting vertex $v_0 in V_0 union V_1$ an instance also uniquely defines a play where if $v_i E != emptyset$ then $v_(i+1) = sigma(v_0 v_1 ... v_i)$ if $v_i in V_0$ and $v_(i+1) = tau(v_0 v_1 ... v_i)$ if $v_i in V_1$, otherwise the play is finite and stops at $v_i$.
  
  // TODO: Do we given a shorthand syntax to such plays?
  It can be proven that if such play is infinite then it will eventually reach a cycle and repeatedly visit those vertices in the same order, that is the play will be $v_0 ... v_k v_(k+1) ... v_n v_(k+1) ... v_n ...$.
]

#definition("winning strategy")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. A strategy $sigma_i$ for player $i$ is called winning on vertex $v$ if for any strategy $sigma_(1-i)$ for the opposing player, the play starting from vertex $v$ in the instance $(G, sigma_0, sigma_1)$ is winning for player $i$.
]

TODO: Cite papers on determinancy (see Jurdzinski)

By the well-known determinancy of parity games we know that each vertex is winning for exactly one of the two players. Moreover it is known that the winning player also has a memoryless winning strategy, that is a strategy that depends only on the current vertex and not on the previous ones. The strategy iteration algorithm will focus on these strategies, as they are much simplier to represent and search for.

#lemma("determinacy of parity games")[
  Given a parity game $G = (V_0, V_1, E, p)$ the winner on each vertex is pre-determined. The set of vertices $V$ can thus be partitioned in two *winning sets* $W_0$ and $W_1$ of the vertices where player 0 (resp. player 1) has a winning strategy starting from vertices in that set.
]

#definition("memoryless strategy")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. A memoryless strategy for player $i$ is a strategy that only depends on the last vertex of the play prefix, or equivalently a function that takes as input a vertex $v in V_i$ with $v E != emptyset$ and returns a vertex in $v E$.
]

#lemma("memoryless winning strategy")[
  Let $G = (V_0, V_1, E, p)$ be a parity game and assume that player $i$ has a winning strategy on vertex $v$. Then player $i$ also has a memoryless strategy on the same vertex $v$.
]