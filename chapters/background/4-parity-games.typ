#import "../../config/common.typ": *

== Parity games

Parity games are games with two players, 0 and 1, performed on directed graphs. A token is placed in a position, represented by nodes, and the two players move it along the edges of the graph. The set of nodes is partitioned in two sets and the player that chooses the move is determined by the subset in which the node for the current position is in. To each node is also associated a _priority_, represented by a natural number. The sequence of positions visited in a game is called _play_ and could be finite or infinite, depending on whether a position with no moves is reached or not. In case of a finite play the player who cannot move loses, otherwise if the play is infinite the priorities of the positions that are visited infinitely many times are considered: if the biggest one is even then player 0 wins, otherwise player 1 is the winner. Players are also sometimes called $exists$ and $forall$ or $lozenge$ and $square$ due to their meaning when using parity games for solving $mu$-calculus or fixpoints.

// TODO: Image example of parity game?

Since we will often use the set of predecessors and successors of a vertex we will define a convenient notation for them. We will also need a formal concept for infinitely recurring elements in a sequence in order to describe the winner of a parity game.

#notation("successors and predecessors")[
  Let $G = (V, E)$ be a graph.
  Given $u, v in V$ we write $u E v$ if the graph contains the edge from $u$ to $v$.
  We write $u E$ as a shorthand for the set ${ v in V | u E v }$ and $E v$ as a shorthand for the set ${ u in V | u E v }$
]

#definition("infinitely recurring elements")[
  Let $pi = v_0 v_1 v_2 ...$ an infinite sequence of elements. We define $inf(pi)$ as the set of infinitely recurring elements of $pi$, that is $inf(pi) = { v | forall n. exists i >= n. v_i = v }$.
]

#definition("parity graph")[
  Let $V$ be a finite set of vertices, $E subset.eq V times V$ a set of edges, and $p: V -> bb(N)$ a so called priority function. A parity graph is a graph $G = (V, E, p)$.
]

#definition("parity game, play")[
  Let $(V, E, p)$ be a parity graph and let $V$ be partitioned into two sets $V_0$ and $V_1$. The tuple $G = (V_0, V_1, E, p)$ is a parity game.
]

#definition("play")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. Starting from a vertex $v_0 in V_0 union V_1$ we can build a potentially infinite sequence $pi = v_0 v_1 ...$ such that $forall i. v_i E v_(i+1)$. If the play is finite, that is $pi = v_0 v_1 ... v_n$, then $v_n E = emptyset$ is also required. Such sequence is called a play.
]

#definition("winner of a play")[
  Let $G = (V_0, V_1, E, p)$ be a parity game and let $pi = v_0 v_1 ...$ be a play. The winner of $pi$ is:
  - if $pi$ is finite, that is $pi = v_0 v_1 ... v_n$ with $v_n in V_i$ then the winner is player $1-i$;
  - if $pi$ is infinite then consider $max inf(p(v_0) p(v_1) ...)$: if it is even the winner is player 0, otherwise it is player 1.
]

We will focus on parity games that are more restriced than this, in particular on _bipartite parity games_ and _total parity games_.
Bipartite parity games are games whose graph is bipartite, forcing players to perfectly alternate moves.
Total parity games instead require every vertex to have at least one successor, thus forcing every play to be infinite.

We will mostly assume bipartite parity games, while we will show that we can convert any parity game to a compatible total parity game.

#definition("bipartite parity game")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. It is also a bipartite parity game if the graph $(V_0, V_1, E)$ is bipartite, that is $forall v in V_i. v E sect V_i = emptyset$.
]

#definition("total parity game")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. It is also a total parity game if every vertex has at least one successor, that if $forall v in V_0 union V_1. v E != emptyset$.
]

=== Strategies

TODO: Don't introduce strategy iteration this early.

The strategy iteration algorithm heavely depends on the concept of _strategies_, which intuitively represent the way a player can choose its moves in a parity game. We will then see plays as being generated by such strategies, and use this to define what it means to be the winner of a parity game on given vertex.

#definition("strategy")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. A strategy for player $i$ is a function taking as input the prefix $v_0 v_1 ... v_n$ of a play such that $v_n in V_i$ and $v_n E != emptyset$ and returns a vertex in $v_n E$.
]

#definition("strategy induced instance")[
  Let $G = (V_0, V_1, E, p)$ be a parity game, $sigma$ be a strategy for player 0 and $tau$ be a strategy for player 1. An instance of the game $G$ induced by the strategies $sigma$ and $tau$ is a tuple $(G, sigma, tau)$.

  Given a starting vertex $v_0 in V_0 union V_1$ an instance also uniquely defines a play where if $v_i E != emptyset$ then $v_(i+1) = sigma(v_0 v_1 ... v_i)$ if $v_i in V_0$ and $v_(i+1) = tau(v_0 v_1 ... v_i)$ if $v_i in V_1$, otherwise the play is finite and stops at $v_i$.
  
  // TODO: Do we given a shorthand syntax to such plays?
  It can be proven that if such play is infinite then it will eventually reach a cycle and repeatedly visit those vertices in the same order, that is the play will be $v_0 ... v_k v_(k+1) ... v_n v_(k+1) ... v_n ...$.
]

#definition("winning strategy")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. A strategy $sigma_i$ for player $i$ is called winning on vertex $v$ if for any strategy $sigma_(1-i)$ for the opposing player, the play starting from vertex $v$ in the instance $(G, sigma_0, sigma_1)$ is winning for player $i$.
]

TODO: Cite papers on determinancy (see Jurdzinski)

By the well-known determinancy of parity games we know that each vertex is winning for exactly one of the two players. Moreover it is known that the winning player also has a memoryless winning strategy, that is a strategy that depends only on the current vertex and not on the previous ones. The strategy iteration algorithm will focus on these strategies, as they are much simplier to represent and search for.

#lemma("determinacy of parity games")[
  Given a parity game $G = (V_0, V_1, E, p)$ the winner on each vertex is pre-determined. The set of vertices $V$ can thus be partitioned in two *winning sets* $W_0$ and $W_1$ of the vertices where player 0 (resp. player 1) has a winning strategy starting from vertices in that set.
]

#definition("memoryless strategy")[
  Let $G = (V_0, V_1, E, p)$ be a parity game. A memoryless strategy for player $i$ is a strategy that only depends on the last vertex of the play prefix, or equivalently a function that takes as input a vertex $v in V_i$ with $v E != emptyset$ and returns a vertex in $v E$.
]

#lemma("memoryless winning strategy")[
  Let $G = (V_0, V_1, E, p)$ be a parity game and assume that player $i$ has a winning strategy on vertex $v$. Then player $i$ also has a memoryless strategy on the same vertex $v$.
]